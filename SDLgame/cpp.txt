#include "EnemyDrone.h"
#include <math.h>

EnemyDrone::EnemyDrone() {}

EnemyDrone::EnemyDrone(float x, float y, GameEngine::SpriteBatch* _sb)
{
	sb = _sb;
}

EnemyDrone::~EnemyDrone()
{
}
void EnemyDrone::draw()
{
	spriteSheet.run();
	spriteSheet.draw(boundingBox.x, boundingBox.y);
}

void EnemyDrone::calcNewPos(float _x, float _y)
{
	boundingBox.y -= + hoverY;
	hoverY += hoverVel;
	if (hoverY > 4) {
		hoverVel -= 0.15;
	}
	if (hoverY < -4) {
		hoverVel += 0.15;
	}
	if (_x != NULL && _y != NULL) {
		float theta = atan(-1 * (_y - boundingBox.y) / (_x - boundingBox.x));
		if (_x > boundingBox.x) {
			boundingBox.yv = sin(theta) * -1 * vel;
			boundingBox.xv = cos(theta) * vel;
		}
		else {
			boundingBox.yv = sin(theta) * vel;
			boundingBox.xv = cos(theta) * -1 * vel;
		}
		if (sqrt(pow(boundingBox.x - _x, 2) + pow(boundingBox.y - _y, 2)) < 100) {
			boundingBox.xv *= -1;
			boundingBox.yv *= -1;
			if (sqrt(pow(boundingBox.x - _x, 2) + pow(boundingBox.y - _y, 2)) > 90) {
				boundingBox.xv = 0;
				boundingBox.yv = 0;
			}
		}
		boundingBox.x += boundingBox.xv;
		boundingBox.y += boundingBox.yv + hoverY;
	}
}

void EnemyDrone::load()
{
	spriteSheet.init(sb, 9, 19, 2, 4, 9, 0, 0);
	spriteSheet.loadTexture("Textures/enemyDrone1.png");
	maxShootCooldown = 20;
	health = 10;
	vel = 2.5;
	hoverVel = -0.5;
}
void EnemyDrone::run()
{
	shootCooldown--;
	calcNewPos(target.x, target.y);
}
void EnemyDrone::setPosition(float _x, float _y)
{
	boundingBox.x = _x;
	boundingBox.y = _y;
}
void EnemyDrone::setTarget(float _x, float _y)
{
	target.x = _x;
	target.y = _y;
}
void EnemyDrone::setTarget(glm::vec2 _target)
{
	target = _target;
}
void EnemyDrone::subtractHealth(int _amount)
{
	health -= _amount;
}
int EnemyDrone::getHealth()
{
	return health;
}
void EnemyDrone::setMode(behaviorType _mode)
{
	mode = _mode;
}

BoundingBox * EnemyDrone::getBoundingBox()
{
	return &boundingBox;
}

glm::vec2 EnemyDrone::getPosition()
{
	return glm::vec2(boundingBox.x, boundingBox.y);
}#include "EnemyDroneCollection.h"
EnemyDroneCollection::EnemyDroneCollection() {}
EnemyDroneCollection::~EnemyDroneCollection() {}
void EnemyDroneCollection::init(GameEngine::SpriteBatch* _sb) {
	sb = _sb;
}
void EnemyDroneCollection::add(float _x, float _y) {
	enemyDroneVector.push_back(new EnemyDrone(_x, _y, sb));
	enemyDroneVector[enemyDroneVector.size() - 1]->setPosition(_x, _y);
	enemyDroneVector[enemyDroneVector.size() - 1]->load();
}

void EnemyDroneCollection::run() {
	for (int i = 0; i < enemyDroneVector.size(); i++)
	{
		enemyDroneVector[i]->setTarget(glm::vec2(targets[getClosestTarget(i)]->x, targets[getClosestTarget(i)]->y));
		enemyDroneVector[i]->run();
		if (enemyDroneVector[i]->getHealth() <= 0) {
			remove(i);
			i--;
		}
	}
}
void EnemyDroneCollection::draw() {
	for (int i = 0; i < enemyDroneVector.size(); i++)
	{
		enemyDroneVector[i]->draw();
	}
}
BoundingBox* EnemyDroneCollection::getBoundingBox(int _index) {
	return enemyDroneVector[_index]->getBoundingBox();
}
void EnemyDroneCollection::remove(int _index) {
	enemyDroneVector.erase(enemyDroneVector.begin() + _index);
}

int EnemyDroneCollection::getClosestTarget(int _index)
{
	float distance = 1000000;
	int index = -1;
	for (int i = 0; i < targets.size(); i++) {
		if (cd.getDistance(glm::vec2(targets[i]->x, targets[i]->y), enemyDroneVector[_index]->getPosition()) < distance) {
			distance = cd.getDistance(glm::vec2(targets[i]->x, targets[i]->y), enemyDroneVector[_index]->getPosition());
			index = i;
		}
	}
	return index;
}

void EnemyDroneCollection::addTarget(BoundingBox* _boundingBox) {
	targets.push_back(_boundingBox);
}#include "Errors.h"

#include <cstdlib>

#include <iostream>
#include <SDL.h>

//Prints out an error message and exits the game
void fatalError(std::string errorString) {
    std::cout << errorString << std::endl;
    std::cout << "Enter any key to quit...";
    int tmp;
    std::cin >> tmp;
    SDL_Quit();
    exit(69);
}#include "Explosion.h"

Explosion::Explosion() {}
Explosion::~Explosion() {}
void Explosion::run() {

}
GameEngine::Light Explosion::getLight() {
	GameEngine::Light light;
	light.radius = 200;
	light.flicker = false;
	light.flickerRange = glm::vec2(100, 200);
	light.color = glm::vec3(1, 0.5, 0.1);
	setLightOffset(30, 28);
	return light;
}
void Explosion::loadSpriteSheet() {
	spriteSheet.init(sb, 30, 28, 2, 7, 4, 0, 0);
	spriteSheet.loadTexture("Textures/explosion.png");
}
ExplosionParticle::ExplosionParticle() {}
ExplosionParticle::~ExplosionParticle() {}
void ExplosionParticle::run() {
	boundingBox.yv -= 0.3;
	boundingBox.x += boundingBox.xv;
	boundingBox.y += boundingBox.yv;
	if (boundingBox.onGround) {
		boundingBox.xv *= 0.9;
	}
	boundingBox.onGround = false;
}
GameEngine::Light ExplosionParticle::getLight() {
	GameEngine::Light light;
	light.radius = 0;
	light.flicker = true;
	light.flickerRange = glm::vec2(15, 20);
	light.color = glm::vec3(1, 0.4, 0.0);
	setLightOffset(3, 3);
	return light;
}
void ExplosionParticle::loadSpriteSheet() {
	spriteSheet.init(sb, 3, 3, 2, 9, 10, 0, 0);
	spriteSheet.loadTexture("Textures/explosionParticle.png");
}
FireParticle::FireParticle() {}
FireParticle::~FireParticle() {}
void FireParticle::run() {
	boundingBox.yv -= 0.4;
	boundingBox.x += boundingBox.xv;
	boundingBox.y += boundingBox.yv;
	if (boundingBox.onGround) {
		boundingBox.xv *= 0.8;
	}
	boundingBox.onGround = false;
}
GameEngine::Light FireParticle::getLight() {
	GameEngine::Light light;
	light.radius = 0;
	light.flicker = true;
	light.flickerRange = glm::vec2(0, 50);
	light.color = glm::vec3(1, 0.5, 0.0);
	setLightOffset(3, 6);
	return light;
}
void FireParticle::loadSpriteSheet() {
	spriteSheet.init(sb, 3, 9, 2, 6, 4, 0, 0);
	spriteSheet.loadTexture("Textures/fireParticle.png");
}#include "Flare.h"

Flare::Flare() {}
Flare::~Flare() {}
void Flare::run() {
	boundingBox.yv -= 0.2;
	boundingBox.x += boundingBox.xv;
	boundingBox.y += boundingBox.yv;
	if (boundingBox.onGround) {
		boundingBox.xv *= 0.95;
	}
	boundingBox.onGround = false;
}
GameEngine::Light Flare::getLight() {
	GameEngine::Light light;
	light.radius = 0;
	light.flicker = true;
	light.flickerRange = glm::vec2(50, 160);
	light.color = glm::vec3(1, 0.15, 0.15);
	return light;
}

FlareParticle::FlareParticle() {}
FlareParticle::~FlareParticle() {}
void FlareParticle::run() {
	boundingBox.yv -= 0.4;
	boundingBox.x += boundingBox.xv;
	boundingBox.y += boundingBox.yv;
	if (boundingBox.onGround) {
		boundingBox.xv *= 0.8;
	}
	boundingBox.onGround = false;
}
GameEngine::Light FlareParticle::getLight() {
	GameEngine::Light light;
	light.radius = 15;
	light.flicker = false;
	light.color = glm::vec3(1, 0.25, 0.25);
	return light;
}#include "GlowStick.h"

GlowStick::GlowStick() {}
GlowStick::~GlowStick() {}
void GlowStick::run() {
	boundingBox.yv -= 0.6;
	boundingBox.x += boundingBox.xv;
	boundingBox.y += boundingBox.yv;
	if (boundingBox.onGround) {
		boundingBox.xv *= 0.9;
	}
	boundingBox.onGround = false;
}
GameEngine::Light GlowStick::getLight() {
	GameEngine::Light light;
	light.radius = 35;
	light.flicker = false;
	light.color = glm::vec3(0.35, 1, 0.6);
	return light;
}#include "GLSLProgram.h"
#include "Errors.h"

#include <vector>

#include <fstream>

//The : _numAttributes(0) ect. is an initialization list. It is a better way to initialize variables, since it avoids an extra copy. 
GLSLProgram::GLSLProgram() : _numAttributes(0), _programID(0), _vertexShaderID(0), _fragmentShaderID(0)
{

}


GLSLProgram::~GLSLProgram()
{
}

//Compiles the shaders into a form that your GPU can understand
void GLSLProgram::compileShaders(const std::string& vertexShaderFilePath, const std::string& fragmentShaderFilepath) {
    //Vertex and fragment shaders are successfully compiled.
    //Now time to link them together into a program.
    //Get a program object.
    _programID = glCreateProgram();

    //Create the vertex shader object, and store its ID
    _vertexShaderID = glCreateShader(GL_VERTEX_SHADER);
    if (_vertexShaderID == 0) {
        fatalError("Vertex shader failed to be created!");
    }

    //Create the fragment shader object, and store its ID
    _fragmentShaderID = glCreateShader(GL_FRAGMENT_SHADER);
    if (_fragmentShaderID == 0) {
        fatalError("Fragment shader failed to be created!");
    }

    //Compile each shader
    compileShader(vertexShaderFilePath, _vertexShaderID);
    compileShader(fragmentShaderFilepath, _fragmentShaderID);
}

void GLSLProgram::linkShaders() {

    //Attach our shaders to our program
    glAttachShader(_programID, _vertexShaderID);
    glAttachShader(_programID, _fragmentShaderID);

    //Link our program
    glLinkProgram(_programID);

    //Note the different functions here: glGetProgram* instead of glGetShader*.
    GLint isLinked = 0;
    glGetProgramiv(_programID, GL_LINK_STATUS, (int *)&isLinked);
    if (isLinked == GL_FALSE)
    {
        GLint maxLength = 0;
        glGetProgramiv(_programID, GL_INFO_LOG_LENGTH, &maxLength);

        //The maxLength includes the NULL character
        std::vector<char> errorLog(maxLength);
        glGetProgramInfoLog(_programID, maxLength, &maxLength, &errorLog[0]);



        //We don't need the program anymore.
        glDeleteProgram(_programID);
        //Don't leak shaders either.
        glDeleteShader(_vertexShaderID);
        glDeleteShader(_fragmentShaderID);

        //print the error log and quit
        std::printf("%s\n", &(errorLog[0]));
        fatalError("Shaders failed to link!");
    }

    //Always detach shaders after a successful link.
    glDetachShader(_programID, _vertexShaderID);
    glDetachShader(_programID, _fragmentShaderID);
    glDeleteShader(_vertexShaderID);
    glDeleteShader(_fragmentShaderID);
}

//Adds an attribute to our shader. SHould be called between compiling and linking.
void GLSLProgram::addAttribute(const std::string& attributeName) {
    glBindAttribLocation(_programID, _numAttributes++, attributeName.c_str());
}

GLint GLSLProgram::getUniformLocation(const std::string& uniformName) {
    GLint location = glGetUniformLocation(_programID, uniformName.c_str());
    if (location == GL_INVALID_INDEX) {
        fatalError("Uniform " + uniformName + " not found in shader!");
    }
    return location;
}

//enable the shader, and all its attributes
void GLSLProgram::use() {
    glUseProgram(_programID);
    //enable all the attributes we added with addAttribute
    for (int i = 0; i < _numAttributes; i++) {
        glEnableVertexAttribArray(i);
    }
}

//disable the shader
void GLSLProgram::unuse() {
    glUseProgram(0);
    for (int i = 0; i < _numAttributes; i++) {
        glDisableVertexAttribArray(i);
    }
}

//Compiles a single shader file
void GLSLProgram::compileShader(const std::string& filePath, GLuint id) {

    //Open the file
    std::ifstream shaderFile(filePath);
    if (shaderFile.fail()) {
        perror(filePath.c_str());
        fatalError("Failed to open " + filePath);
    }

    //File contents stores all the text in the file
    std::string fileContents = "";
    //line is used to grab each line of the file
    std::string line;

    //Get all the lines in the file and add it to the contents
    while (std::getline(shaderFile, line)) {
        fileContents += line + "\n";
    }

    shaderFile.close();

    //get a pointer to our file contents c string;
    const char* contentsPtr = fileContents.c_str();
    //tell opengl that we want to use fileContents as the contents of the shader file
    glShaderSource(id, 1, &contentsPtr, nullptr);

    //compile the shader
    glCompileShader(id);

    //check for errors
    GLint success = 0;
    glGetShaderiv(id, GL_COMPILE_STATUS, &success);

    if (success == GL_FALSE)
    {
        GLint maxLength = 0;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &maxLength);

        //The maxLength includes the NULL character
        std::vector<char> errorLog(maxLength);
        glGetShaderInfoLog(id, maxLength, &maxLength, &errorLog[0]);

        //Provide the infolog in whatever manor you deem best.
        //Exit with failure.
        glDeleteShader(id); //Don't leak the shader.

        //Print error log and quit
        std::printf("%s\n", &(errorLog[0]));
        fatalError("Shader " + filePath + " failed to compile");
    }
}#include "ImageLoader.h"
#include "picoPNG.h"
#include "IOManager.h"
#include "Errors.h"

GLTexture ImageLoader::loadPNG(std::string filePath) {
    //Create a GLTexture and initialize all its fields to 0
    GLTexture texture = {};
    
    //This is the input data to decodePNG, which we load from a file
    std::vector<unsigned char> in;
    //This is the output data from decodePNG, which is the pixel data for our texture
    std::vector<unsigned char> out;

    unsigned long width, height;

    //Read in the image file contents into a buffer
    if (IOManager::readFileToBuffer(filePath, in) == false) {
        fatalError("Failed to load PNG file to buffer!");
    }

    //Decode the .png format into an array of pixels
    int errorCode = decodePNG(out, width, height, &(in[0]), in.size());
    if (errorCode != 0) {
        fatalError("decodePNG failed with error: " + std::to_string(errorCode));
    }

    //Generate the openGL texture object
    glGenTextures(1, &(texture.id));

    //Bind the texture object
    glBindTexture(GL_TEXTURE_2D, texture.id);
    //Upload the pixels to the texture
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, &(out[0]));

    //Set some texture parameters
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);

    //Generate the mipmaps
    glGenerateMipmap(GL_TEXTURE_2D);

    //Unbind the texture
    glBindTexture(GL_TEXTURE_2D, 0);

    texture.width = width;
    texture.height = height;

    //Return a copy of the texture data
    return texture;
}#include "Inventory.h"
#include <GameEngine\ResourceManager.h>

Inventory::Inventory()
{
}


Inventory::~Inventory()
{
}
void Inventory::init(GameEngine::SpriteBatch * _sb, GameEngine::DrawText* _drawText) {
	sb = _sb;
	drawText = _drawText;
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			storage[i][j].type = InventoryNone;
			storage[i][j].amount = 0;
		}
	}
	for (int i = 0; i < 4; i++) {
		hotBar[i].type = InventoryNone;
		hotBar[i].amount = 0;
	}
	cellDrawSize = 100;
	flareTexture = GameEngine::ResourceManager::getTexture("Textures/flareIcon.png");
	glowStickTexture = GameEngine::ResourceManager::getTexture("Textures/glowStickIcon.png");
}
void Inventory::addItem(inventoryitemType _type, int _amount) {
	bool finished = false;
	for (int i = 0; i < 4; i++) {
		if (!finished) {
			for (int j = 0; j < 4; j++) {
				if (!finished) {
					if (storage[i][j].type == _type)
					{
						storage[i][j].amount += _amount;
						finished = true;
					}
					if (storage[i][j].type == InventoryNone)
					{
						storage[i][j].type = _type;
						storage[i][j].amount = _amount;
						finished = true;
					}
				}
				else
				{
					break;
				}
			}
		}
		else
		{
			break;
		}
	}
}
bool Inventory::removeItem(inventoryitemType _type, int _amount) {
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (storage[i][j].type == _type)
			{
				if (storage[i][j].amount < _amount) {
					return false;
				}
				else {
					storage[i][j].amount -= _amount;
					if (storage[i][j].amount == 0) {
						storage[i][j].type = InventoryNone;
					}
					return true;
				}
			}

		}
	}
	return false;
}
void Inventory::draw(float _x, float _y) {
	_x = _x - (4 * cellDrawSize) / 2;
	_y = _y - (4 * cellDrawSize) / 2;
	GameEngine::Color color;
	color.r = 120;
	color.g = 200;
	color.b = 120;
	color.a = 70;
	GameEngine::drawRect(_x - 2, _y - 2, cellDrawSize * 4 + 5, cellDrawSize * 4 + 5, 0, color, sb);
	color.r = 120;
	color.g = 200;
	color.b = 120;
	color.a = 120;
	for (int i = 0; i < 5; i++) {
		GameEngine::drawRect(_x + (cellDrawSize * i), _y, 1, cellDrawSize * 4 + 1, 0, color, sb);
	}
	for (int i = 0; i < 5; i++) {
		GameEngine::drawRect(_x, _y + (cellDrawSize * i), cellDrawSize * 4 + 1, 1, 0, color, sb);
	}
	
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			if (storage[i][j].amount>0) {
				drawText->draw(_x + cellDrawSize * i + 7, _y + cellDrawSize * j + 7, storage[i][j].amount, 2);
			}
			GameEngine::drawRect(_x + cellDrawSize * i + 3, _y + cellDrawSize * j + 3, cellDrawSize - 5, 1, 0, color, sb);
			GameEngine::drawRect(_x + cellDrawSize * i + 3, _y + cellDrawSize * j + 3, 1, cellDrawSize - 5, 0, color, sb);
			GameEngine::drawRect(_x + cellDrawSize * i + cellDrawSize - 3, _y + cellDrawSize * j + 3, 1, cellDrawSize - 5, 0, color, sb);
			GameEngine::drawRect(_x + cellDrawSize * i + 3, _y + cellDrawSize * j + cellDrawSize - 3, cellDrawSize - 5, 1, 0, color, sb);
			drawItem(storage[i][j], _x + cellDrawSize * i + (cellDrawSize - 40) / 2, _y + cellDrawSize * j + (cellDrawSize - 40) / 2);
		}
	}
}
void Inventory::drawItem(InventoryItem _item, float _x, float _y) {
	int textureID;
	bool draw = true;
	switch (_item.type) {
		case InventoryFlare:
			textureID = flareTexture.id;
			break;
		case InventoryGlowStick:
			textureID = glowStickTexture.id;
			break;
		case InventoryNone:
			draw = false;
			break;
	}
	if (draw)
	{
		GameEngine::Color color;
		color.r = 255;
		color.g = 0;
		color.b = 255;
		color.a = 255;
		sb->draw(glm::vec4(_x, _y, 40, 40), glm::vec4(0, 0, 1, 1), textureID, 0.0f, color, 0);
	}
}#include "InventoryItem.h"



InventoryItem::InventoryItem()
{
}


InventoryItem::~InventoryItem()
{
}
#include "IOManager.h"

#include <fstream>

bool IOManager::readFileToBuffer(std::string filePath, std::vector<unsigned char>& buffer) {
    std::ifstream file(filePath, std::ios::binary);
    if (file.fail()) {
        perror(filePath.c_str());
        return false;
    }

    //seek to the end
    file.seekg(0, std::ios::end);

    //Get the file size
    int fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    //Reduce the file size by any header bytes that might be present
    fileSize -= file.tellg();

    buffer.resize(fileSize);
    file.read((char *)&(buffer[0]), fileSize);
    file.close();

    return true;
}#include "LightCollection.h"
#include <iostream>
LightCollection::LightCollection()
{

}
LightCollection::~LightCollection()
{

}
void LightCollection::setMaxLights(int _maxlights) {
	maxLights = _maxlights;
}
int LightCollection::addLight(float x, float y, float r, float g, float b, float radius, glm::vec2 _flickerRange) {
	if (lightVector.size() < maxLights)
	{
		GameEngine::Light newLight;
		newLight.x = x;
		newLight.y = y;
newLight.radius = radius;
newLight.color = glm::vec3(r, g, b);
newLight.flicker = true;
newLight.flickerRange = _flickerRange;
newLight.ID = lastLightID + 1;
lastLightID++;
lightVector.push_back(newLight);
//std::cout << "lights: " << lightVector.size() << std::endl;
return newLight.ID;
	}
	else {
		std::cout << "Maximum amount of lights reached!" << std::endl;
		return 0;
	}
}
int LightCollection::addLight(float x, float y, float r, float g, float b, float radius) {
	if (lightVector.size() < maxLights)
	{
		GameEngine::Light newLight;
		newLight.x = x;
		newLight.y = y;
		newLight.radius = radius;
		newLight.color = glm::vec3(r, g, b);
		newLight.flicker = false;
		newLight.ID = lastLightID + 1;
		lastLightID++;
		lightVector.push_back(newLight);
		//std::cout << "lights: " << lightVector.size() << std::endl;
		return newLight.ID;
	}
	else {
		std::cout << "Maximum amount of lights reached!" << std::endl;
		return 0;
	}
}
int LightCollection::addLight(GameEngine::Light _light) {
	if (lightVector.size() < maxLights)
	{
		_light.ID = lastLightID + 1;
		lastLightID++;
		lightVector.push_back(_light);
		//std::cout << "lights: " << lightVector.size() << std::endl;
		return _light.ID;
	}
	else {
		std::cout << "Maximum amount of lights reached!" << std::endl;
		return -1;
	}
}
void LightCollection::addLightsToShader(GameEngine::GLSLProgram* _shaderProgram) {
	const int size = 200;
	float lightColourArray[size * 3];
	//std::cout << "lights: " << lightVector.size() << std::endl;
	for (unsigned int i = 0; i < lightVector.size(); i++)
	{
		lightColourArray[i * 3] = lightVector[i].color.r;
		lightColourArray[(i * 3) + 1] = lightVector[i].color.g;
		lightColourArray[(i * 3) + 2] = lightVector[i].color.b;
	}
	float lightPositionArray[size * 2];
	for (unsigned int i = 0; i < lightVector.size(); i++)
	{
		lightPositionArray[i * 2] = lightVector[i].x;
		lightPositionArray[(i * 2) + 1] = lightVector[i].y;
	}
	float lightRadiusArray[size];
	for (unsigned int i = 0; i < lightVector.size(); i++)
	{
		lightRadiusArray[i] = lightVector[i].radius;
	}
	GLint lightArraySize = _shaderProgram->getUniformLocation("lightArraySize");
	glUniform1i(lightArraySize, lightVector.size());
	GLint lightColours = _shaderProgram->getUniformLocation("lightColours");
	glUniform1fv(lightColours, size * 3, lightColourArray);
	GLint lightPositions = _shaderProgram->getUniformLocation("lightPositions");
	glUniform1fv(lightPositions, size * 2, lightPositionArray);
	GLint lightRadii = _shaderProgram->getUniformLocation("lightRadii");
	glUniform1fv(lightRadii, size, lightRadiusArray);
}
int LightCollection::getVectorIndexByID(int _ID) {
	for (int i = 0; i < lightVector.size(); i++) {
		if (lightVector[i].ID == _ID) {
			return i;
		}
	}
	std::cout << "No Light found with ID " << _ID << std::endl;
	return -1;
}
void LightCollection::changePosition(int _ID, float _x, float _y) {
	int index = getVectorIndexByID(_ID);
	lightVector[index].x = _x;
	lightVector[index].y = _y;
}
void LightCollection::changeRadius(int _ID, float _radius) {
	lightVector[getVectorIndexByID(_ID)].radius = _radius;
}
void LightCollection::addToRadius(int _ID, float _radius) {
	if (lightVector[getVectorIndexByID(_ID)].radius > 0)
	{
		lightVector[getVectorIndexByID(_ID)].radius += _radius;
		if (lightVector[getVectorIndexByID(_ID)].radius  < 0) {
			lightVector[getVectorIndexByID(_ID)].radius = 0;
		}
	}
}
void LightCollection::runFlicker() {
	for (int i = 0; i < lightVector.size(); i++) {
		if (lightVector[i].flicker) {
			lightVector[i].radius = ((double)rand() / (RAND_MAX)) * (lightVector[i].flickerRange.y - lightVector[i].flickerRange.x) + lightVector[i].flickerRange.x;
		}
	}
}
void LightCollection::removeLight(int _ID) {
	
	int index = getVectorIndexByID(_ID);
	if (index != -1) {
		lightVector.erase(lightVector.begin() + index);
	}
	
}#include <iostream>
#include "MainGame.h"

int main(int argc, char** argv) {
    MainGame mainGame;
    mainGame.run();

    return 0;
}﻿#include "MainGame.h"
#include <GameEngine/Errors.h>
#include <GameEngine/ResourceManager.h>
#include <math.h>
#include <iostream>
#include <string>


//Constructor, just initializes private member variables
MainGame::MainGame() :
	_screenWidth(1400),
	_screenHeight(800),
	_time(0.0f),
	_gameState(GameState::PLAY),
	_maxFPS(60.0f),
	maxLights(100)
{
    _camera.init(_screenWidth, _screenHeight, -50, 3200);
}

//Destructor
MainGame::~MainGame()
{
}

//This runs the game
void MainGame::run() {
    initSystems();

 
    //This only returns when the game ends
    gameLoop();
}

//Initialize SDL and Opengl and whatever else we need
void MainGame::initSystems() {

    GameEngine::init();

    _window.create("Game Engine", _screenWidth, _screenHeight, 0);

    initShaders();

    _spriteBatch.init();
    _fpsLimiter.init(_maxFPS);
	Lights.setMaxLights(200);
	Lights.addLight(0, 9000, 1, 1, 1, 12500);
	Lights.addLight(-400, -7100, 0.2, 0.2, 1, 100);
	Platforms.addPlatform(-200, 3000, 800, 16);
	Platforms.addPlatform(-800, 3000, 400, 16);
	Platforms.addPlatform(-400, 3040, 400, 16);
	Platforms.addPlatform(400, 3040, 400, 16);
	Platforms.addPlatform(-800, 2400, 800, 16);
	Platforms.addPlatform(0, 1800, 800, 16);
	Platforms.addPlatform(-800, 1200, 800, 16);
	Platforms.addPlatform(0, 600, 800, 16);
	Platforms.addPlatform(-800, 0, 800, 16);
	Platforms.addPlatform(0, -600, 800, 16);
	Platforms.addPlatform(-800, -1200, 800, 16);
	Platforms.addPlatform(0, -1800, 800, 16);
	Platforms.addPlatform(-800, -2400, 800, 16);
	Platforms.addPlatform(0, -3000, 800, 16);
	Platforms.addPlatform(-800, -3600, 800, 16);
	Platforms.addPlatform(0, -4200, 800, 16);
	Platforms.addPlatform(-800, -4800, 800, 16);
	Platforms.addPlatform(0, -5400, 800, 16);
	Platforms.addPlatform(-800, -6000, 800, 16);
	Platforms.addPlatform(0, -6600, 800, 16);
	Platforms.addPlatform(-800, -7200, 800, 16);
	player.init(360, 3400, &WorldItems, &_spriteBatch, &drawText);
	WorldItems.init(&Lights, &_spriteBatch);
	drawText.init(&_spriteBatch);
	_camera.setScreenShakeIntensity(10);
	WorldItems.addItem(explosion, -100, 3200);
	drones.init(&_spriteBatch);
	drones.add(0, 3200);
	drones.addTarget(player.getBoundingBox());
}

void MainGame::initShaders() {
    _colorProgram.compileShaders("Shaders/colorShading.vert", "Shaders/colorShading.frag");
    _colorProgram.addAttribute("vertexPosition");
    _colorProgram.addAttribute("vertexColor");
    _colorProgram.addAttribute("vertexUV");
	_colorProgram.addAttribute("test");
    _colorProgram.linkShaders();

}

//This is the main game loop for our program
void MainGame::gameLoop() {

    //Will loop until we set _gameState to EXIT
    while (_gameState != GameState::EXIT) {
       
        _fpsLimiter.begin();

        processInput();
        _time += 0.1;

		

        _camera.update();

		updateGame();

        drawGame();

        _fps = _fpsLimiter.end();

        //print only once every 10 frames
        static int frameCounter = 0;
        frameCounter++;
        if (frameCounter == 1000) {
            std::cout << _fps << std::endl;
            frameCounter = 0;
        }
    }
}
void MainGame::updateGame() {
	player.handleInput(&_inputManager);
	WorldItems.runItems();
	drones.run();
	_camera.followObject(player.getBoundingBox());
	for (int j = 0; j < Platforms.getVectorSize(); j++)
	{
		cd.correctPosition(player.getBoundingBox(), Platforms.getBoundingBox(j));
		for (int i = 0; i < WorldItems.getVectorSize(); i++)
		{
			if (cd.isCheckRequired(WorldItems.getBoundingBox(i), Platforms.getBoundingBox(j)))
			{
				cd.correctPosition(WorldItems.getBoundingBox(i), Platforms.getBoundingBox(j));
			}
		}
	}
	player.calcNewPos();

}
//Processes input with SDL
void MainGame::processInput() {
    SDL_Event evnt;

    const float CAMERA_SPEED = 2.0f;
    const float SCALE_SPEED = 0.1f;

    //Will keep looping until there are no more events to process
    while (SDL_PollEvent(&evnt)) {
        switch (evnt.type) {
            case SDL_QUIT:
                _gameState = GameState::EXIT;
                break;
            case SDL_MOUSEMOTION:
                //std::cout << evnt.motion.x << " " << evnt.motion.y << std::endl;
				_inputManager.setMouseCoords(evnt.motion.x, evnt.motion.y);
                break;
            case SDL_KEYDOWN:
                _inputManager.pressKey(evnt.key.keysym.sym);
                break;
            case SDL_KEYUP:
                _inputManager.releaseKey(evnt.key.keysym.sym);
                break;
			case SDL_MOUSEBUTTONDOWN:
				_inputManager.pressKey(evnt.button.button);
				break;
			case SDL_MOUSEBUTTONUP:
				_inputManager.releaseKey(evnt.button.button);
				break;
				
		}
    }
	/*
    if (_inputManager.isKeyPressed(SDLK_w)) {
        _camera.setPosition(_camera.getPosition() + glm::vec2(0.0f, CAMERA_SPEED));
		lightPos.y+=10;
    }
    if (_inputManager.isKeyPressed(SDLK_s)) {
        _camera.setPosition(_camera.getPosition() + glm::vec2(0.0f, -CAMERA_SPEED));
		lightPos.y-=10;
    }
    if (_inputManager.isKeyPressed(SDLK_a)) {
        _camera.setPosition(_camera.getPosition() + glm::vec2(-CAMERA_SPEED, 0.0f));
		lightPos.x-=10;
    }
    if (_inputManager.isKeyPressed(SDLK_d)) {
        _camera.setPosition(_camera.getPosition() + glm::vec2(CAMERA_SPEED, 0.0f));
		lightPos.x+=10;
    }*/
    if (_inputManager.isKeyPressed(SDLK_q)) {
        _camera.setScale(_camera.getScale() + SCALE_SPEED);
    }
    if (_inputManager.isKeyPressed(SDLK_e)) {
        _camera.setScale(_camera.getScale() - SCALE_SPEED);
    }

	if (_inputManager.isKeyPressed(SDL_BUTTON_LEFT)) {
		glm::vec2 mouseCoords = _inputManager.getMouseCoords();
		mouseCoords = _camera.convertScreenToWorld(mouseCoords);
		if (!lastPressedL) {
			WorldItems.addItem(glowStick, mouseCoords.x, -mouseCoords.y);
		}
		lastPressedL = true;
	}
	else { lastPressedL = false; }
	if (_inputManager.isKeyPressed(SDL_BUTTON_RIGHT)) {
		glm::vec2 mouseCoords = _inputManager.getMouseCoords();
		mouseCoords = _camera.convertScreenToWorld(mouseCoords);
		if (!lastPressedR) {
			_camera.setScreenShakeIntensity(6);
			WorldItems.addItem(explosion, mouseCoords.x, -mouseCoords.y);
		}
		lastPressedR = true;
	}
	else { lastPressedR = false; }
}

//Draws the game using the almighty OpenGL
void MainGame::drawGame() {
	
	WorldItems.linkToLights();
	Lights.runFlicker();
	//std::cout << flare.x << "," << flare.y << "," << flare.z << "," << flare.w << std::endl;
    //Set the base depth to 1.0
    glClearDepth(1.0);
    //Clear the color and depth buffer
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	glLineWidth(1);
	
	glm::mat4 camera = _camera.getCameraMatrix();

	glColor3f(0.0, 0.0, 0.0);
	glBegin(GL_POLYGON);
	glVertex2f(-1, -1);
	glVertex2f(-1, 1);
	glVertex2f(1, 1);
	glVertex2f(1, -1);
	glEnd();
    //Enable the shader
    _colorProgram.use();
	GLint vignette = _colorProgram.getUniformLocation("vignette");
	glUniform2f(vignette, _camera.getPosition().x, _camera.getPosition().y);
	GLint ambientLight = _colorProgram.getUniformLocation("ambientLight");
	glUniform1f(ambientLight, 0.1);
    //We are using texture unit 0
    glActiveTexture(GL_TEXTURE0);
    //Get the uniform location
    GLint textureLocation = _colorProgram.getUniformLocation("mySampler");
    //Tell the shader that the texture is in texture unit 0
    glUniform1i(textureLocation, 0);

    //Set the camera matrixx
    GLint pLocation = _colorProgram.getUniformLocation("P");
    glm::mat4 cameraMatrix = _camera.getCameraMatrix();

    glUniformMatrix4fv(pLocation, 1, GL_FALSE, &(cameraMatrix[0][0]));

	//-----------------PASSING LIGHTS INTO SHADER-----------------//
	Lights.addLightsToShader(&_colorProgram);
	//------------------------------------------------------------//
    _spriteBatch.begin();
    glm::vec4 pos(-100.0f, -100.0f, 500.0f, 500.0f);
    glm::vec4 uv(0.0f, 0.0f, 1.0f, 1.0f);
	static GameEngine::GLTexture texture = GameEngine::ResourceManager::getTexture("Textures/jimmyJump_pack/PNG/CharacterRight_Standing.png");
	glm::vec4 pos1(-1000.0f, 1000.0f, 2000.0f, -2000.0f);
	glm::vec4 uv1(0.0f, 0.0f, 1.0f, 1.0f);
	//static GameEngine::GLTexture newTexture = GameEngine::ResourceManager::getTexture("Textures/jimmyJump_pack/PNG/b1.png");
	//static GameEngine::GLTexture newTexture1 = GameEngine::ResourceManager::getTexture("Textures/jimmyJump_pack/PNG/b2.png");
	static GameEngine::GLTexture db = GameEngine::ResourceManager::getTexture("Textures/decentBackground.png");
	static GameEngine::GLTexture mb = GameEngine::ResourceManager::getTexture("Textures/meshBackground.png");
	static GameEngine::GLTexture test = GameEngine::ResourceManager::getTexture("Textures/guardian.png");
    GameEngine::Color color;
    color.r = 255;
    color.g = 0;
    color.b = 255;
    color.a = 255;
	//_spriteBatch.draw(pos1, uv1, newTexture1.id, 0.0f, color, 0.5);
	//_spriteBatch.draw(pos1, uv1, newTexture.id, 0.0f, color, 1);
	
	_spriteBatch.draw(glm::vec4(-6500 / 2, -6500 / 2, 6500, 6500) + glm::vec4(_camera.getPosition().x - _camera.getVelocity().x, _camera.getPosition().y - _camera.getVelocity().y, 0, 0)*glm::vec4(0.8, 0.8, 0, 0), uv1, db.id, 0.0f, color, 0);
	//_spriteBatch.draw(glm::vec4(-9500 / 2, -5500 / 2, 9500, 5500) + glm::vec4(_camera.getPosition().x - _camera.getVelocity().x, _camera.getPosition().y - _camera.getVelocity().y, 0, 0)*glm::vec4(0.6, 0.7, 0, 0), uv1, mb.id, 0.0f, color, 0.5);
	_spriteBatch.draw(glm::vec4(-9500 / 2, -5500 / 2, 9500, 5500) + glm::vec4(_camera.getPosition().x - _camera.getVelocity().x, _camera.getPosition().y - _camera.getVelocity().y, 0, 0)*glm::vec4(0.6, 0.6, 0, 0), uv1, mb.id, 0.0f, color, 0.7);
	_spriteBatch.draw(glm::vec4(-9500 / 2, -5500 / 2, 9500, 5500) + glm::vec4(_camera.getPosition().x - _camera.getVelocity().x, _camera.getPosition().y - _camera.getVelocity().y, 0, 0)*glm::vec4(0.6, 0.6, 0, 0) + glm::vec4(3, 3, 0, 0), uv1, mb.id, 0.0f, color, 0.9);
	_spriteBatch.draw(glm::vec4(0.0f, 3000.0f, 28 * 2, 67 * 2), glm::vec4(0.0f, 0.0f, 1.0f, 1.0f), test.id, 0.0f, color, 1);

    _spriteBatch.draw(pos, uv, texture.id, 0.0f, color);
	GameEngine::drawRect(300, 0, 600, 600, 1, color, &_spriteBatch);
	_spriteBatch.drawLine(glm::vec2(0, 3200), glm::vec2(100, 3100), 255, 150, 0, 255);
	//_spriteBatch.drawLine(glm::vec2(0, 3200), glm::vec2(100, 3100), color);
	Platforms.drawPlatforms(&_spriteBatch);
	player.draw();
	if (_inputManager.isKeyPressed(SDLK_TAB)) {
		player.drawInventory(_camera.getPosition() - _camera.getVelocity());
	}
	drawText.draw(0, 0, "a", 2);
	drawText.draw(10, 0, 1, 2);
	drawText.draw(20, 0, 2, 2);
	drawText.draw(30, 0, 3, 1);
	drawText.draw(40, 0, 4, 1); 
	//drawText.draw(-30, 3100, "a", 1);
	WorldItems.drawItems();
	drawText.drawAll(-30, 3100, 3);
	drones.draw();
	_spriteBatch.end();
	
    _spriteBatch.renderBatch();

    //unbind the texture
    glBindTexture(GL_TEXTURE_2D, 0);


    //disable the shader
    _colorProgram.unuse();

    //Swap our buffer and draw everything to the screen!
    _window.swapBuffer();
}    
void MainGame::addLight(float x, float y, float r, float g, float b, float radius) {
	if (lightVector.size() < maxLights)
	{
		GameEngine::Light newLight;
		newLight.x = x;
		newLight.y = y;
		newLight.radius = radius;
		newLight.color = glm::vec3(r, g, b);
		lightVector.push_back(newLight);
		std::cout << "lights: " << lightVector.size() << std::endl;
	}
	else {
		std::cout << "Maximum amount of lights reached!" << std::endl;
	}
}#include <vector>

/*
decodePNG: The picoPNG function, decodes a PNG file buffer in memory, into a raw pixel buffer.
out_image: output parameter, this will contain the raw pixels after decoding.
By default the output is 32-bit RGBA color.
The std::vector is automatically resized to the correct size.
image_width: output_parameter, this will contain the width of the image in pixels.
image_height: output_parameter, this will contain the height of the image in pixels.
in_png: pointer to the buffer of the PNG file in memory. To get it from a file on
disk, load it and store it in a memory buffer yourself first.
in_size: size of the input PNG file in bytes.
convert_to_rgba32: optional parameter, true by default.
Set to true to get the output in RGBA 32-bit (8 bit per channel) color format
no matter what color type the original PNG image had. This gives predictable,
useable data from any random input PNG.
Set to false to do no color conversion at all. The result then has the same data
type as the PNG image, which can range from 1 bit to 64 bits per pixel.
Information about the color type or palette colors are not provided. You need
to know this information yourself to be able to use the data so this only
works for trusted PNG files. Use LodePNG instead of picoPNG if you need this information.
return: 0 if success, not 0 if some error occured.
*/
int decodePNG(std::vector<unsigned char>& out_image, unsigned long& image_width, unsigned long& image_height, const unsigned char* in_png, size_t in_size, bool convert_to_rgba32)
{
    // picoPNG version 20101224
    // Copyright (c) 2005-2010 Lode Vandevenne
    //
    // This software is provided 'as-is', without any express or implied
    // warranty. In no event will the authors be held liable for any damages
    // arising from the use of this software.
    //
    // Permission is granted to anyone to use this software for any purpose,
    // including commercial applications, and to alter it and redistribute it
    // freely, subject to the following restrictions:
    //
    //     1. The origin of this software must not be misrepresented; you must not
    //     claim that you wrote the original software. If you use this software
    //     in a product, an acknowledgment in the product documentation would be
    //     appreciated but is not required.
    //     2. Altered source versions must be plainly marked as such, and must not be
    //     misrepresented as being the original software.
    //     3. This notice may not be removed or altered from any source distribution.

    // picoPNG is a PNG decoder in one C++ function of around 500 lines. Use picoPNG for
    // programs that need only 1 .cpp file. Since it's a single function, it's very limited,
    // it can convert a PNG to raw pixel data either converted to 32-bit RGBA color or
    // with no color conversion at all. For anything more complex, another tiny library
    // is available: LodePNG (lodepng.c(pp)), which is a single source and header file.
    // Apologies for the compact code style, it's to make this tiny.

    static const unsigned long LENBASE[29] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258 };
    static const unsigned long LENEXTRA[29] = { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 };
    static const unsigned long DISTBASE[30] = { 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 };
    static const unsigned long DISTEXTRA[30] = { 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 };
    static const unsigned long CLCL[19] = { 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 }; //code length code lengths
    struct Zlib //nested functions for zlib decompression
    {
        static unsigned long readBitFromStream(size_t& bitp, const unsigned char* bits) { unsigned long result = (bits[bitp >> 3] >> (bitp & 0x7)) & 1; bitp++; return result; }
        static unsigned long readBitsFromStream(size_t& bitp, const unsigned char* bits, size_t nbits)
        {
            unsigned long result = 0;
            for (size_t i = 0; i < nbits; i++) result += (readBitFromStream(bitp, bits)) << i;
            return result;
        }
        struct HuffmanTree
        {
            int makeFromLengths(const std::vector<unsigned long>& bitlen, unsigned long maxbitlen)
            { //make tree given the lengths
                unsigned long numcodes = (unsigned long)(bitlen.size()), treepos = 0, nodefilled = 0;
                std::vector<unsigned long> tree1d(numcodes), blcount(maxbitlen + 1, 0), nextcode(maxbitlen + 1, 0);
                for (unsigned long bits = 0; bits < numcodes; bits++) blcount[bitlen[bits]]++; //count number of instances of each code length
                for (unsigned long bits = 1; bits <= maxbitlen; bits++) nextcode[bits] = (nextcode[bits - 1] + blcount[bits - 1]) << 1;
                for (unsigned long n = 0; n < numcodes; n++) if (bitlen[n] != 0) tree1d[n] = nextcode[bitlen[n]]++; //generate all the codes
                tree2d.clear(); tree2d.resize(numcodes * 2, 32767); //32767 here means the tree2d isn't filled there yet
                for (unsigned long n = 0; n < numcodes; n++) //the codes
                for (unsigned long i = 0; i < bitlen[n]; i++) //the bits for this code
                {
                    unsigned long bit = (tree1d[n] >> (bitlen[n] - i - 1)) & 1;
                    if (treepos > numcodes - 2) return 55;
                    if (tree2d[2 * treepos + bit] == 32767) //not yet filled in
                    {
                        if (i + 1 == bitlen[n]) { tree2d[2 * treepos + bit] = n; treepos = 0; } //last bit
                        else { tree2d[2 * treepos + bit] = ++nodefilled + numcodes; treepos = nodefilled; } //addresses are encoded as values > numcodes
                    } else treepos = tree2d[2 * treepos + bit] - numcodes; //subtract numcodes from address to get address value
                }
                return 0;
            }
            int decode(bool& decoded, unsigned long& result, size_t& treepos, unsigned long bit) const
            { //Decodes a symbol from the tree
                unsigned long numcodes = (unsigned long)tree2d.size() / 2;
                if (treepos >= numcodes) return 11; //error: you appeared outside the codetree
                result = tree2d[2 * treepos + bit];
                decoded = (result < numcodes);
                treepos = decoded ? 0 : result - numcodes;
                return 0;
            }
            std::vector<unsigned long> tree2d; //2D representation of a huffman tree: The one dimension is "0" or "1", the other contains all nodes and leaves of the tree.
        };
        struct Inflator
        {
            int error;
            void inflate(std::vector<unsigned char>& out, const std::vector<unsigned char>& in, size_t inpos = 0)
            {
                size_t bp = 0, pos = 0; //bit pointer and byte pointer
                error = 0;
                unsigned long BFINAL = 0;
                while (!BFINAL && !error)
                {
                    if (bp >> 3 >= in.size()) { error = 52; return; } //error, bit pointer will jump past memory
                    BFINAL = readBitFromStream(bp, &in[inpos]);
                    unsigned long BTYPE = readBitFromStream(bp, &in[inpos]); BTYPE += 2 * readBitFromStream(bp, &in[inpos]);
                    if (BTYPE == 3) { error = 20; return; } //error: invalid BTYPE
                    else if (BTYPE == 0) inflateNoCompression(out, &in[inpos], bp, pos, in.size());
                    else inflateHuffmanBlock(out, &in[inpos], bp, pos, in.size(), BTYPE);
                }
                if (!error) out.resize(pos); //Only now we know the true size of out, resize it to that
            }
            void generateFixedTrees(HuffmanTree& tree, HuffmanTree& treeD) //get the tree of a deflated block with fixed tree
            {
                std::vector<unsigned long> bitlen(288, 8), bitlenD(32, 5);;
                for (size_t i = 144; i <= 255; i++) bitlen[i] = 9;
                for (size_t i = 256; i <= 279; i++) bitlen[i] = 7;
                tree.makeFromLengths(bitlen, 15);
                treeD.makeFromLengths(bitlenD, 15);
            }
            HuffmanTree codetree, codetreeD, codelengthcodetree; //the code tree for Huffman codes, dist codes, and code length codes
            unsigned long huffmanDecodeSymbol(const unsigned char* in, size_t& bp, const HuffmanTree& codetree, size_t inlength)
            { //decode a single symbol from given list of bits with given code tree. return value is the symbol
                bool decoded; unsigned long ct;
                for (size_t treepos = 0;;)
                {
                    if ((bp & 0x07) == 0 && (bp >> 3) > inlength) { error = 10; return 0; } //error: end reached without endcode
                    error = codetree.decode(decoded, ct, treepos, readBitFromStream(bp, in)); if (error) return 0; //stop, an error happened
                    if (decoded) return ct;
                }
            }
            void getTreeInflateDynamic(HuffmanTree& tree, HuffmanTree& treeD, const unsigned char* in, size_t& bp, size_t inlength)
            { //get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree
                std::vector<unsigned long> bitlen(288, 0), bitlenD(32, 0);
                if (bp >> 3 >= inlength - 2) { error = 49; return; } //the bit pointer is or will go past the memory
                size_t HLIT = readBitsFromStream(bp, in, 5) + 257; //number of literal/length codes + 257
                size_t HDIST = readBitsFromStream(bp, in, 5) + 1; //number of dist codes + 1
                size_t HCLEN = readBitsFromStream(bp, in, 4) + 4; //number of code length codes + 4
                std::vector<unsigned long> codelengthcode(19); //lengths of tree to decode the lengths of the dynamic tree
                for (size_t i = 0; i < 19; i++) codelengthcode[CLCL[i]] = (i < HCLEN) ? readBitsFromStream(bp, in, 3) : 0;
                error = codelengthcodetree.makeFromLengths(codelengthcode, 7); if (error) return;
                size_t i = 0, replength;
                while (i < HLIT + HDIST)
                {
                    unsigned long code = huffmanDecodeSymbol(in, bp, codelengthcodetree, inlength); if (error) return;
                    if (code <= 15)  { if (i < HLIT) bitlen[i++] = code; else bitlenD[i++ - HLIT] = code; } //a length code
                    else if (code == 16) //repeat previous
                    {
                        if (bp >> 3 >= inlength) { error = 50; return; } //error, bit pointer jumps past memory
                        replength = 3 + readBitsFromStream(bp, in, 2);
                        unsigned long value; //set value to the previous code
                        if ((i - 1) < HLIT) value = bitlen[i - 1];
                        else value = bitlenD[i - HLIT - 1];
                        for (size_t n = 0; n < replength; n++) //repeat this value in the next lengths
                        {
                            if (i >= HLIT + HDIST) { error = 13; return; } //error: i is larger than the amount of codes
                            if (i < HLIT) bitlen[i++] = value; else bitlenD[i++ - HLIT] = value;
                        }
                    } else if (code == 17) //repeat "0" 3-10 times
                    {
                        if (bp >> 3 >= inlength) { error = 50; return; } //error, bit pointer jumps past memory
                        replength = 3 + readBitsFromStream(bp, in, 3);
                        for (size_t n = 0; n < replength; n++) //repeat this value in the next lengths
                        {
                            if (i >= HLIT + HDIST) { error = 14; return; } //error: i is larger than the amount of codes
                            if (i < HLIT) bitlen[i++] = 0; else bitlenD[i++ - HLIT] = 0;
                        }
                    } else if (code == 18) //repeat "0" 11-138 times
                    {
                        if (bp >> 3 >= inlength) { error = 50; return; } //error, bit pointer jumps past memory
                        replength = 11 + readBitsFromStream(bp, in, 7);
                        for (size_t n = 0; n < replength; n++) //repeat this value in the next lengths
                        {
                            if (i >= HLIT + HDIST) { error = 15; return; } //error: i is larger than the amount of codes
                            if (i < HLIT) bitlen[i++] = 0; else bitlenD[i++ - HLIT] = 0;
                        }
                    } else { error = 16; return; } //error: somehow an unexisting code appeared. This can never happen.
                }
                if (bitlen[256] == 0) { error = 64; return; } //the length of the end code 256 must be larger than 0
                error = tree.makeFromLengths(bitlen, 15); if (error) return; //now we've finally got HLIT and HDIST, so generate the code trees, and the function is done
                error = treeD.makeFromLengths(bitlenD, 15); if (error) return;
            }
            void inflateHuffmanBlock(std::vector<unsigned char>& out, const unsigned char* in, size_t& bp, size_t& pos, size_t inlength, unsigned long btype)
            {
                if (btype == 1) { generateFixedTrees(codetree, codetreeD); } else if (btype == 2) { getTreeInflateDynamic(codetree, codetreeD, in, bp, inlength); if (error) return; }
                for (;;)
                {
                    unsigned long code = huffmanDecodeSymbol(in, bp, codetree, inlength); if (error) return;
                    if (code == 256) return; //end code
                    else if (code <= 255) //literal symbol
                    {
                        if (pos >= out.size()) out.resize((pos + 1) * 2); //reserve more room
                        out[pos++] = (unsigned char)(code);
                    } else if (code >= 257 && code <= 285) //length code
                    {
                        size_t length = LENBASE[code - 257], numextrabits = LENEXTRA[code - 257];
                        if ((bp >> 3) >= inlength) { error = 51; return; } //error, bit pointer will jump past memory
                        length += readBitsFromStream(bp, in, numextrabits);
                        unsigned long codeD = huffmanDecodeSymbol(in, bp, codetreeD, inlength); if (error) return;
                        if (codeD > 29) { error = 18; return; } //error: invalid dist code (30-31 are never used)
                        unsigned long dist = DISTBASE[codeD], numextrabitsD = DISTEXTRA[codeD];
                        if ((bp >> 3) >= inlength) { error = 51; return; } //error, bit pointer will jump past memory
                        dist += readBitsFromStream(bp, in, numextrabitsD);
                        size_t start = pos, back = start - dist; //backwards
                        if (pos + length >= out.size()) out.resize((pos + length) * 2); //reserve more room
                        for (size_t i = 0; i < length; i++) { out[pos++] = out[back++]; if (back >= start) back = start - dist; }
                    }
                }
            }
            void inflateNoCompression(std::vector<unsigned char>& out, const unsigned char* in, size_t& bp, size_t& pos, size_t inlength)
            {
                while ((bp & 0x7) != 0) bp++; //go to first boundary of byte
                size_t p = bp / 8;
                if (p >= inlength - 4) { error = 52; return; } //error, bit pointer will jump past memory
                unsigned long LEN = in[p] + 256 * in[p + 1], NLEN = in[p + 2] + 256 * in[p + 3]; p += 4;
                if (LEN + NLEN != 65535) { error = 21; return; } //error: NLEN is not one's complement of LEN
                if (pos + LEN >= out.size()) out.resize(pos + LEN);
                if (p + LEN > inlength) { error = 23; return; } //error: reading outside of in buffer
                for (unsigned long n = 0; n < LEN; n++) out[pos++] = in[p++]; //read LEN bytes of literal data
                bp = p * 8;
            }
        };
        int decompress(std::vector<unsigned char>& out, const std::vector<unsigned char>& in) //returns error value
        {
            Inflator inflator;
            if (in.size() < 2) { return 53; } //error, size of zlib data too small
            if ((in[0] * 256 + in[1]) % 31 != 0) { return 24; } //error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way
            unsigned long CM = in[0] & 15, CINFO = (in[0] >> 4) & 15, FDICT = (in[1] >> 5) & 1;
            if (CM != 8 || CINFO > 7) { return 25; } //error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec
            if (FDICT != 0) { return 26; } //error: the specification of PNG says about the zlib stream: "The additional flags shall not specify a preset dictionary."
            inflator.inflate(out, in, 2);
            return inflator.error; //note: adler32 checksum was skipped and ignored
        }
    };
    struct PNG //nested functions for PNG decoding
    {
        struct Info
        {
            unsigned long width, height, colorType, bitDepth, compressionMethod, filterMethod, interlaceMethod, key_r, key_g, key_b;
            bool key_defined; //is a transparent color key given?
            std::vector<unsigned char> palette;
        } info;
        int error;
        void decode(std::vector<unsigned char>& out, const unsigned char* in, size_t size, bool convert_to_rgba32)
        {
            error = 0;
            if (size == 0 || in == 0) { error = 48; return; } //the given data is empty
            readPngHeader(&in[0], size); if (error) return;
            size_t pos = 33; //first byte of the first chunk after the header
            std::vector<unsigned char> idat; //the data from idat chunks
            bool IEND = false, known_type = true;
            info.key_defined = false;
            while (!IEND) //loop through the chunks, ignoring unknown chunks and stopping at IEND chunk. IDAT data is put at the start of the in buffer
            {
                if (pos + 8 >= size) { error = 30; return; } //error: size of the in buffer too small to contain next chunk
                size_t chunkLength = read32bitInt(&in[pos]); pos += 4;
                if (chunkLength > 2147483647) { error = 63; return; }
                if (pos + chunkLength >= size) { error = 35; return; } //error: size of the in buffer too small to contain next chunk
                if (in[pos + 0] == 'I' && in[pos + 1] == 'D' && in[pos + 2] == 'A' && in[pos + 3] == 'T') //IDAT chunk, containing compressed image data
                {
                    idat.insert(idat.end(), &in[pos + 4], &in[pos + 4 + chunkLength]);
                    pos += (4 + chunkLength);
                } else if (in[pos + 0] == 'I' && in[pos + 1] == 'E' && in[pos + 2] == 'N' && in[pos + 3] == 'D')  { pos += 4; IEND = true; } else if (in[pos + 0] == 'P' && in[pos + 1] == 'L' && in[pos + 2] == 'T' && in[pos + 3] == 'E') //palette chunk (PLTE)
                {
                    pos += 4; //go after the 4 letters
                    info.palette.resize(4 * (chunkLength / 3));
                    if (info.palette.size() > (4 * 256)) { error = 38; return; } //error: palette too big
                    for (size_t i = 0; i < info.palette.size(); i += 4)
                    {
                        for (size_t j = 0; j < 3; j++) info.palette[i + j] = in[pos++]; //RGB
                        info.palette[i + 3] = 255; //alpha
                    }
                } else if (in[pos + 0] == 't' && in[pos + 1] == 'R' && in[pos + 2] == 'N' && in[pos + 3] == 'S') //palette transparency chunk (tRNS)
                {
                    pos += 4; //go after the 4 letters
                    if (info.colorType == 3)
                    {
                        if (4 * chunkLength > info.palette.size()) { error = 39; return; } //error: more alpha values given than there are palette entries
                        for (size_t i = 0; i < chunkLength; i++) info.palette[4 * i + 3] = in[pos++];
                    } else if (info.colorType == 0)
                    {
                        if (chunkLength != 2) { error = 40; return; } //error: this chunk must be 2 bytes for greyscale image
                        info.key_defined = 1; info.key_r = info.key_g = info.key_b = 256 * in[pos] + in[pos + 1]; pos += 2;
                    } else if (info.colorType == 2)
                    {
                        if (chunkLength != 6) { error = 41; return; } //error: this chunk must be 6 bytes for RGB image
                        info.key_defined = 1;
                        info.key_r = 256 * in[pos] + in[pos + 1]; pos += 2;
                        info.key_g = 256 * in[pos] + in[pos + 1]; pos += 2;
                        info.key_b = 256 * in[pos] + in[pos + 1]; pos += 2;
                    } else { error = 42; return; } //error: tRNS chunk not allowed for other color models
                } else //it's not an implemented chunk type, so ignore it: skip over the data
                {
                    if (!(in[pos + 0] & 32)) { error = 69; return; } //error: unknown critical chunk (5th bit of first byte of chunk type is 0)
                    pos += (chunkLength + 4); //skip 4 letters and uninterpreted data of unimplemented chunk
                    known_type = false;
                }
                pos += 4; //step over CRC (which is ignored)
            }
            unsigned long bpp = getBpp(info);
            std::vector<unsigned char> scanlines(((info.width * (info.height * bpp + 7)) / 8) + info.height); //now the out buffer will be filled
            Zlib zlib; //decompress with the Zlib decompressor
            error = zlib.decompress(scanlines, idat); if (error) return; //stop if the zlib decompressor returned an error
            size_t bytewidth = (bpp + 7) / 8, outlength = (info.height * info.width * bpp + 7) / 8;
            out.resize(outlength); //time to fill the out buffer
            unsigned char* out_ = outlength ? &out[0] : 0; //use a regular pointer to the std::vector for faster code if compiled without optimization
            if (info.interlaceMethod == 0) //no interlace, just filter
            {
                size_t linestart = 0, linelength = (info.width * bpp + 7) / 8; //length in bytes of a scanline, excluding the filtertype byte
                if (bpp >= 8) //byte per byte
                for (unsigned long y = 0; y < info.height; y++)
                {
                    unsigned long filterType = scanlines[linestart];
                    const unsigned char* prevline = (y == 0) ? 0 : &out_[(y - 1) * info.width * bytewidth];
                    unFilterScanline(&out_[linestart - y], &scanlines[linestart + 1], prevline, bytewidth, filterType, linelength); if (error) return;
                    linestart += (1 + linelength); //go to start of next scanline
                } else //less than 8 bits per pixel, so fill it up bit per bit
                {
                    std::vector<unsigned char> templine((info.width * bpp + 7) >> 3); //only used if bpp < 8
                    for (size_t y = 0, obp = 0; y < info.height; y++)
                    {
                        unsigned long filterType = scanlines[linestart];
                        const unsigned char* prevline = (y == 0) ? 0 : &out_[(y - 1) * info.width * bytewidth];
                        unFilterScanline(&templine[0], &scanlines[linestart + 1], prevline, bytewidth, filterType, linelength); if (error) return;
                        for (size_t bp = 0; bp < info.width * bpp;) setBitOfReversedStream(obp, out_, readBitFromReversedStream(bp, &templine[0]));
                        linestart += (1 + linelength); //go to start of next scanline
                    }
                }
            } else //interlaceMethod is 1 (Adam7)
            {
                size_t passw[7] = { (info.width + 7) / 8, (info.width + 3) / 8, (info.width + 3) / 4, (info.width + 1) / 4, (info.width + 1) / 2, (info.width + 0) / 2, (info.width + 0) / 1 };
                size_t passh[7] = { (info.height + 7) / 8, (info.height + 7) / 8, (info.height + 3) / 8, (info.height + 3) / 4, (info.height + 1) / 4, (info.height + 1) / 2, (info.height + 0) / 2 };
                size_t passstart[7] = { 0 };
                size_t pattern[28] = { 0, 4, 0, 2, 0, 1, 0, 0, 0, 4, 0, 2, 0, 1, 8, 8, 4, 4, 2, 2, 1, 8, 8, 8, 4, 4, 2, 2 }; //values for the adam7 passes
                for (int i = 0; i < 6; i++) passstart[i + 1] = passstart[i] + passh[i] * ((passw[i] ? 1 : 0) + (passw[i] * bpp + 7) / 8);
                std::vector<unsigned char> scanlineo((info.width * bpp + 7) / 8), scanlinen((info.width * bpp + 7) / 8); //"old" and "new" scanline
                for (int i = 0; i < 7; i++)
                    adam7Pass(&out_[0], &scanlinen[0], &scanlineo[0], &scanlines[passstart[i]], info.width, pattern[i], pattern[i + 7], pattern[i + 14], pattern[i + 21], passw[i], passh[i], bpp);
            }
            if (convert_to_rgba32 && (info.colorType != 6 || info.bitDepth != 8)) //conversion needed
            {
                std::vector<unsigned char> data = out;
                error = convert(out, &data[0], info, info.width, info.height);
            }
        }
        void readPngHeader(const unsigned char* in, size_t inlength) //read the information from the header and store it in the Info
        {
            if (inlength < 29) { error = 27; return; } //error: the data length is smaller than the length of the header
            if (in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71 || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10) { error = 28; return; } //no PNG signature
            if (in[12] != 'I' || in[13] != 'H' || in[14] != 'D' || in[15] != 'R') { error = 29; return; } //error: it doesn't start with a IHDR chunk!
            info.width = read32bitInt(&in[16]); info.height = read32bitInt(&in[20]);
            info.bitDepth = in[24]; info.colorType = in[25];
            info.compressionMethod = in[26]; if (in[26] != 0) { error = 32; return; } //error: only compression method 0 is allowed in the specification
            info.filterMethod = in[27]; if (in[27] != 0) { error = 33; return; } //error: only filter method 0 is allowed in the specification
            info.interlaceMethod = in[28]; if (in[28] > 1) { error = 34; return; } //error: only interlace methods 0 and 1 exist in the specification
            error = checkColorValidity(info.colorType, info.bitDepth);
        }
        void unFilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon, size_t bytewidth, unsigned long filterType, size_t length)
        {
            switch (filterType)
            {
                case 0: for (size_t i = 0; i < length; i++) recon[i] = scanline[i]; break;
                case 1:
                    for (size_t i = 0; i < bytewidth; i++) recon[i] = scanline[i];
                    for (size_t i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
                    break;
                case 2:
                    if (precon) for (size_t i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
                    else       for (size_t i = 0; i < length; i++) recon[i] = scanline[i];
                    break;
                case 3:
                    if (precon)
                    {
                        for (size_t i = 0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
                        for (size_t i = bytewidth; i < length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
                    } else
                    {
                        for (size_t i = 0; i < bytewidth; i++) recon[i] = scanline[i];
                        for (size_t i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
                    }
                    break;
                case 4:
                    if (precon)
                    {
                        for (size_t i = 0; i < bytewidth; i++) recon[i] = scanline[i] + paethPredictor(0, precon[i], 0);
                        for (size_t i = bytewidth; i < length; i++) recon[i] = scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]);
                    } else
                    {
                        for (size_t i = 0; i < bytewidth; i++) recon[i] = scanline[i];
                        for (size_t i = bytewidth; i < length; i++) recon[i] = scanline[i] + paethPredictor(recon[i - bytewidth], 0, 0);
                    }
                    break;
                default: error = 36; return; //error: unexisting filter type given
            }
        }
        void adam7Pass(unsigned char* out, unsigned char* linen, unsigned char* lineo, const unsigned char* in, unsigned long w, size_t passleft, size_t passtop, size_t spacex, size_t spacey, size_t passw, size_t passh, unsigned long bpp)
        { //filter and reposition the pixels into the output when the image is Adam7 interlaced. This function can only do it after the full image is already decoded. The out buffer must have the correct allocated memory size already.
            if (passw == 0) return;
            size_t bytewidth = (bpp + 7) / 8, linelength = 1 + ((bpp * passw + 7) / 8);
            for (unsigned long y = 0; y < passh; y++)
            {
                unsigned char filterType = in[y * linelength], *prevline = (y == 0) ? 0 : lineo;
                unFilterScanline(linen, &in[y * linelength + 1], prevline, bytewidth, filterType, (w * bpp + 7) / 8); if (error) return;
                if (bpp >= 8) for (size_t i = 0; i < passw; i++) for (size_t b = 0; b < bytewidth; b++) //b = current byte of this pixel
                    out[bytewidth * w * (passtop + spacey * y) + bytewidth * (passleft + spacex * i) + b] = linen[bytewidth * i + b];
                else for (size_t i = 0; i < passw; i++)
                {
                    size_t obp = bpp * w * (passtop + spacey * y) + bpp * (passleft + spacex * i), bp = i * bpp;
                    for (size_t b = 0; b < bpp; b++) setBitOfReversedStream(obp, out, readBitFromReversedStream(bp, &linen[0]));
                }
                unsigned char* temp = linen; linen = lineo; lineo = temp; //swap the two buffer pointers "line old" and "line new"
            }
        }
        static unsigned long readBitFromReversedStream(size_t& bitp, const unsigned char* bits) { unsigned long result = (bits[bitp >> 3] >> (7 - (bitp & 0x7))) & 1; bitp++; return result; }
        static unsigned long readBitsFromReversedStream(size_t& bitp, const unsigned char* bits, unsigned long nbits)
        {
            unsigned long result = 0;
            for (size_t i = nbits - 1; i < nbits; i--) result += ((readBitFromReversedStream(bitp, bits)) << i);
            return result;
        }
        void setBitOfReversedStream(size_t& bitp, unsigned char* bits, unsigned long bit) { bits[bitp >> 3] |= (bit << (7 - (bitp & 0x7))); bitp++; }
        unsigned long read32bitInt(const unsigned char* buffer) { return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3]; }
        int checkColorValidity(unsigned long colorType, unsigned long bd) //return type is a LodePNG error code
        {
            if ((colorType == 2 || colorType == 4 || colorType == 6)) { if (!(bd == 8 || bd == 16)) return 37; else return 0; } else if (colorType == 0) { if (!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; else return 0; } else if (colorType == 3) { if (!(bd == 1 || bd == 2 || bd == 4 || bd == 8)) return 37; else return 0; } else return 31; //unexisting color type
        }
        unsigned long getBpp(const Info& info)
        {
            if (info.colorType == 2) return (3 * info.bitDepth);
            else if (info.colorType >= 4) return (info.colorType - 2) * info.bitDepth;
            else return info.bitDepth;
        }
        int convert(std::vector<unsigned char>& out, const unsigned char* in, Info& infoIn, unsigned long w, unsigned long h)
        { //converts from any color type to 32-bit. return value = LodePNG error code
            size_t numpixels = w * h, bp = 0;
            out.resize(numpixels * 4);
            unsigned char* out_ = out.empty() ? 0 : &out[0]; //faster if compiled without optimization
            if (infoIn.bitDepth == 8 && infoIn.colorType == 0) //greyscale
            for (size_t i = 0; i < numpixels; i++)
            {
                out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[i];
                out_[4 * i + 3] = (infoIn.key_defined && in[i] == infoIn.key_r) ? 0 : 255;
            } else if (infoIn.bitDepth == 8 && infoIn.colorType == 2) //RGB color
            for (size_t i = 0; i < numpixels; i++)
            {
                for (size_t c = 0; c < 3; c++) out_[4 * i + c] = in[3 * i + c];
                out_[4 * i + 3] = (infoIn.key_defined == 1 && in[3 * i + 0] == infoIn.key_r && in[3 * i + 1] == infoIn.key_g && in[3 * i + 2] == infoIn.key_b) ? 0 : 255;
            } else if (infoIn.bitDepth == 8 && infoIn.colorType == 3) //indexed color (palette)
            for (size_t i = 0; i < numpixels; i++)
            {
                if (4U * in[i] >= infoIn.palette.size()) return 46;
                for (size_t c = 0; c < 4; c++) out_[4 * i + c] = infoIn.palette[4 * in[i] + c]; //get rgb colors from the palette
            } else if (infoIn.bitDepth == 8 && infoIn.colorType == 4) //greyscale with alpha
            for (size_t i = 0; i < numpixels; i++)
            {
                out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[2 * i + 0];
                out_[4 * i + 3] = in[2 * i + 1];
            } else if (infoIn.bitDepth == 8 && infoIn.colorType == 6) for (size_t i = 0; i < numpixels; i++) for (size_t c = 0; c < 4; c++) out_[4 * i + c] = in[4 * i + c]; //RGB with alpha
            else if (infoIn.bitDepth == 16 && infoIn.colorType == 0) //greyscale
            for (size_t i = 0; i < numpixels; i++)
            {
                out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[2 * i];
                out_[4 * i + 3] = (infoIn.key_defined && 256U * in[i] + in[i + 1] == infoIn.key_r) ? 0 : 255;
            } else if (infoIn.bitDepth == 16 && infoIn.colorType == 2) //RGB color
            for (size_t i = 0; i < numpixels; i++)
            {
                for (size_t c = 0; c < 3; c++) out_[4 * i + c] = in[6 * i + 2 * c];
                out_[4 * i + 3] = (infoIn.key_defined && 256U * in[6 * i + 0] + in[6 * i + 1] == infoIn.key_r && 256U * in[6 * i + 2] + in[6 * i + 3] == infoIn.key_g && 256U * in[6 * i + 4] + in[6 * i + 5] == infoIn.key_b) ? 0 : 255;
            } else if (infoIn.bitDepth == 16 && infoIn.colorType == 4) //greyscale with alpha
            for (size_t i = 0; i < numpixels; i++)
            {
                out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = in[4 * i]; //most significant byte
                out_[4 * i + 3] = in[4 * i + 2];
            } else if (infoIn.bitDepth == 16 && infoIn.colorType == 6) for (size_t i = 0; i < numpixels; i++) for (size_t c = 0; c < 4; c++) out_[4 * i + c] = in[8 * i + 2 * c]; //RGB with alpha
            else if (infoIn.bitDepth < 8 && infoIn.colorType == 0) //greyscale
            for (size_t i = 0; i < numpixels; i++)
            {
                unsigned long value = (readBitsFromReversedStream(bp, in, infoIn.bitDepth) * 255) / ((1 << infoIn.bitDepth) - 1); //scale value from 0 to 255
                out_[4 * i + 0] = out_[4 * i + 1] = out_[4 * i + 2] = (unsigned char)(value);
                out_[4 * i + 3] = (infoIn.key_defined && value && ((1U << infoIn.bitDepth) - 1U) == infoIn.key_r && ((1U << infoIn.bitDepth) - 1U)) ? 0 : 255;
            } else if (infoIn.bitDepth < 8 && infoIn.colorType == 3) //palette
            for (size_t i = 0; i < numpixels; i++)
            {
                unsigned long value = readBitsFromReversedStream(bp, in, infoIn.bitDepth);
                if (4 * value >= infoIn.palette.size()) return 47;
                for (size_t c = 0; c < 4; c++) out_[4 * i + c] = infoIn.palette[4 * value + c]; //get rgb colors from the palette
            }
            return 0;
        }
        unsigned char paethPredictor(short a, short b, short c) //Paeth predicter, used by PNG filter type 4
        {
            short p = a + b - c, pa = p > a ? (p - a) : (a - p), pb = p > b ? (p - b) : (b - p), pc = p > c ? (p - c) : (c - p);
            return (unsigned char)((pa <= pb && pa <= pc) ? a : pb <= pc ? b : c);
        }
    };
    PNG decoder; decoder.decode(out_image, in_png, in_size, convert_to_rgba32);
    image_width = decoder.info.width; image_height = decoder.info.height;
    return decoder.error;
}#include "Platform.h"
#include <GameEngine\GameEngine.h>
Platform::Platform(){}
Platform::~Platform() {}
void Platform::init(float _x, float _y, float _width, float _height) {
	boundingBox.x = _x;
	boundingBox.y = _y;
	boundingBox.w = _width;
	boundingBox.h = _height;
	boundingBox.xv = 0;
	boundingBox.yv = 0;
	texture = GameEngine::ResourceManager::getTexture("Textures/basicPlatform8x1000.png");
}
BoundingBox* Platform::getBoundingBox() {
	return &boundingBox;
}
void Platform::draw(GameEngine::SpriteBatch* sb) {
	GameEngine::Color color;
	color.r = 255;
	color.g = 255;
	color.b = 255;
	color.a = 255;
	//GameEngine::drawRect(boundingBox.x, boundingBox.y, boundingBox.w, boundingBox.h, 1, color, sb);
	sb->draw(glm::vec4(boundingBox.x, boundingBox.y, boundingBox.w, boundingBox.h), glm::vec4(0, 0, boundingBox.w/(1000*2), 1), texture.id, 0.0f, color, 1);
}#include "PlatformCollection.h"
PlatformCollection::PlatformCollection() {}
PlatformCollection::~PlatformCollection() {}
void PlatformCollection::addPlatform(float _x, float _y, float _width, float _height) {
	platformVector.push_back(new Platform);
	platformVector[platformVector.size()-1]->init(_x, _y, _width, _height);
}
void PlatformCollection::drawPlatforms(GameEngine::SpriteBatch* sb) {
	for (int i = 0; i < platformVector.size(); i++)
	{
		platformVector[i]->draw(sb);
	}
}
BoundingBox* PlatformCollection::getBoundingBox(int _index) {
	return platformVector[_index]->getBoundingBox();
}#include "Player.h"
#include <SDL.h>
#include <GameEngine\GameEngine.h>
#include <iostream>

Player::Player()
{
}
Player::~Player()
{
}
void Player::init(float _x, float _y, WorldItemCollection* _itemCollectionPointer, GameEngine::SpriteBatch* _sb, GameEngine::DrawText* _drawText) {
	sb = _sb;
	boundingBox.x = _x;
	boundingBox.y = _y;
	boundingBox.w = 10;
	boundingBox.h = 50;
	boundingBox.xv = 0;
	boundingBox.yv = 0;
	vel = 4;
	jumpLatch = true;
	useLatch = true;
	itemCollectionPointer = _itemCollectionPointer;
	inventory.init(sb, _drawText);
	inventory.addItem(InventoryFlare, 2);
	inventory.addItem(InventoryGlowStick, 5);
	walkRight.init(sb, 13, 25, 2, 8, 6, -5, 0);
	walkRight.loadTexture("textures/player_walk_right.png");
	walkLeft.init(sb, 13, 25, 2, 8, 6, -4, 0);
	walkLeft.loadTexture("textures/player_walk_left.png");
	standRight.init(sb, 10, 25, 2, 1, 1, -4, 0);
	standRight.loadTexture("textures/player_standing_right.png");
	standLeft.init(sb, 10, 25, 2, 1, 1, -1, 0);
	standLeft.loadTexture("textures/player_standing_left.png");
}
BoundingBox* Player::getBoundingBox() {
	return &boundingBox;
}
void Player::handleInput(GameEngine::InputManager* _im) {

	if (_im->isKeyPressed(SDLK_w)) {
		if (jumpLatch && boundingBox.onGround)
		{
			boundingBox.yv = 2*vel;
			jumpLatch = false;
		}
		
	}
	else
	{
		jumpLatch = true;
	}
	boundingBox.onGround = false;
	if (_im->isKeyPressed(SDLK_a)) {
		boundingBox.xv = -vel;
	}
	else
	{
		boundingBox.xv = 0;
	}
	if (_im->isKeyPressed(SDLK_s)) {
		//boundingBox.yv = -vel;
	}
	if (_im->isKeyPressed(SDLK_d)) {
		boundingBox.xv = vel;
	}
	if (_im->isKeyPressed(SDLK_r)) {
		if (useLatch) {
				if (inventory.removeItem(InventoryFlare, 1)) {
				itemCollectionPointer->addItem(flare, boundingBox.x, boundingBox.y, boundingBox.xv, boundingBox.yv);
			}
		}
		useLatch = false;
	}
	else if (_im->isKeyPressed(SDLK_t)) {
		if (useLatch) {
			if (inventory.removeItem(InventoryGlowStick, 1)) {
				itemCollectionPointer->addItem(glowStick, boundingBox.x, boundingBox.y, boundingBox.xv, boundingBox.yv);
			}
		}
		useLatch = false;
	}
	else {
		useLatch = true;
	}
	
}
void Player::calcNewPos() {
	boundingBox.yv -= 0.5;
	boundingBox.x += boundingBox.xv;
	boundingBox.y += boundingBox.yv;
}
void Player::draw() {
	if (boundingBox.xv > 0) {
		lastDirectionRight = true;
		walkRight.run();
		walkRight.draw(boundingBox.x, boundingBox.y);
	}
	else {
		walkRight.reset();
		if (boundingBox.xv < 0) {
			lastDirectionRight = false;
			walkLeft.run();
			walkLeft.draw(boundingBox.x, boundingBox.y);
		}
		else {
			walkLeft.reset();
			if (boundingBox.xv == 0) {
				if (lastDirectionRight) {
					standRight.draw(boundingBox.x, boundingBox.y);
				}
				else {
					standLeft.draw(boundingBox.x, boundingBox.y);
				}
			}
		}
	}

	//GameEngine::drawRect(boundingBox.x, boundingBox.y, boundingBox.w, boundingBox.h, 1, color, sb);
	//sb->draw(glm::vec4(boundingBox.x, boundingBox.y, boundingBox.w, boundingBox.h), glm::vec4((1.0f / 8.0f)*frame, 0, 1.0f/8.0f, 1), texture.id, 1, color, 1);
}
void Player::drawInventory(glm::vec2 _position) {
	GameEngine::Color color;
	color.r = 150;
	color.g = 150;
	color.b = 150;
	color.a = 255;
	inventory.draw(_position.x, _position.y);
	
}
#include "Projectile.h"

Projectile::Projectile()
{
}

Projectile::~Projectile()
{
}

void Projectile::init(float _x, float _y, float _xVel, float _yVel)
{
	position.x = _x;
	position.y = _y;
	velocity.x = _xVel;
	velocity.y = _yVel;
	lastPosition = position;
	drawPosition = position;
}

void Projectile::calcNewPos()
{
	drawPosition = lastPosition;
	lastPosition = position;
	position += velocity;
}

void Projectile::draw()
{
	sb->drawLine(position, drawPosition, 255, 150, 0, 255);
}
#include "ResourceManager.h"

TextureCache ResourceManager::_textureCache;

GLTexture ResourceManager::getTexture(std::string texturePath) {
	return _textureCache.getTexture(texturePath);
}#include "Sprite.h"
#include "Vertex.h"
#include "ResourceManager.h"

#include <cstddef>

Sprite::Sprite()
{
    //Always initialize your buffer IDs to 0
    _vboID = 0;
}


Sprite::~Sprite()
{
    //Always remember to delete your buffers when
    //you are done!
    if (_vboID != 0) {
        glDeleteBuffers(1, &_vboID);
    }
}

//Initializes the sprite VBO. x, y, width, and height are
//in the normalized device coordinate space. so, [-1, 1]
void Sprite::init(float x, float y, float width, float height, std::string texturePath) {
    //Set up our private vars
    _x = x;
    _y = y;
    _width = width;
    _height = height;

	_texture = ResourceManager::getTexture(texturePath);

    //Generate the buffer if it hasn't already been generated
    if (_vboID == 0) {
        glGenBuffers(1, &_vboID);
    }

    //This array will hold our vertex data.
    //We need 6 vertices, and each vertex has 2
    //floats for X and Y
    Vertex vertexData[6];

    //First Triangle
    vertexData[0].setPosition(x + width, y + height);
    vertexData[0].setUV(1.0f, 1.0f);

    vertexData[1].setPosition(x, y + height);
    vertexData[1].setUV(0.0f, 1.0f);

    vertexData[2].setPosition(x, y);
    vertexData[2].setUV(0.0f, 0.0f);

    //Second Triangle
    vertexData[3].setPosition(x, y);
    vertexData[3].setUV(0.0f, 0.0f);

    vertexData[4].setPosition(x + width, y);
    vertexData[4].setUV(1.0f, 0.0f);

    vertexData[5].setPosition(x + width, y + height);
    vertexData[5].setUV(1.0f, 1.0f);

    //Set all vertex colors to magenta
    for (int i = 0; i < 6; i++) {
        vertexData[4].setColor(255, 0, 255, 255);
    }

    vertexData[4].setColor(0, 0, 255, 255);

    vertexData[4].setColor(0, 255, 0, 255);


    //Tell opengl to bind our vertex buffer object
    glBindBuffer(GL_ARRAY_BUFFER, _vboID);
    //Upload the data to the GPU
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexData), vertexData, GL_STATIC_DRAW);

    //Unbind the buffer (optional)
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}

//Draws the sprite to the screen
void Sprite::draw() {

	glBindTexture(GL_TEXTURE_2D, _texture.id);

    //bind the buffer object
    glBindBuffer(GL_ARRAY_BUFFER, _vboID);

    //Tell opengl that we want to use the first
    //attribute array. We only need one array right
    //now since we are only using position.
    glEnableVertexAttribArray(0);

    //This is the position attribute pointer
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, position));
    //This is the color attribute pointer
    glVertexAttribPointer(1, 4, GL_UNSIGNED_BYTE, GL_TRUE, sizeof(Vertex), (void*)offsetof(Vertex, color));
    //This is the UV attribute pointer
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, uv));

    //Draw the 6 vertices to the screen
    glDrawArrays(GL_TRIANGLES, 0, 6);

    //Disable the vertex attrib array. This is not optional.
    glDisableVertexAttribArray(0);

    //Unbind the VBO
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}#include "TextureCache.h"
#include "ImageLoader.h"
#include <iostream>

TextureCache::TextureCache()
{
}


TextureCache::~TextureCache()
{
}

GLTexture TextureCache::getTexture(std::string texturePath)
{
	//lookup the texture and see if its in the map
	auto mit = _textureMap.find(texturePath);

	//check if its not in the map
	if (mit == _textureMap.end()) {
		//load the texture
		GLTexture newTexture = ImageLoader::loadPNG(texturePath);

		//insert it into the map
		_textureMap.insert(make_pair(texturePath, newTexture));

		std::cout << "Used Cached Texture!\n";
		return newTexture;
	}
	std::cout << "Loaded Texture!\n";
	return mit->second;
}
#include "WorldItem.h"

WorldItem::WorldItem() {}
WorldItem::~WorldItem() {}
void WorldItem::init(float _x, float _y, float _w, float _h)
{
	setPosition(_x, _y);
	setSize(_w, _h);
	setVel(0, 0);
	despawns = false;
}
void WorldItem::init(float _x, float _y, float _w, float _h, int _timer)
{
	setPosition(_x, _y);
	setSize(_w, _h);
	setVel(0, 0);
	despawns = true;
	deSpawnTimer = _timer;
}
BoundingBox* WorldItem::getBoundingBox()
{
	return &boundingBox;
}
void WorldItem::setLightID(int _ID) {
	lightID = _ID;
}
void WorldItem::setSize(float _width, float _height) {
	boundingBox.w = _width;
	boundingBox.h = _height;
}
void WorldItem::setVel(float _xVel, float _yVel) {
	boundingBox.xv = _xVel;
	boundingBox.yv = _yVel;
}
void WorldItem::addToVel(float _xVel, float _yVel) {
	boundingBox.xv += _xVel;
	boundingBox.yv += _yVel;
}
void WorldItem::setPosition(float _x, float _y) {
	boundingBox.x = _x;
	boundingBox.y = _y;
}
void WorldItem::addToPosition(float _x, float _y) {
	boundingBox.x += _x;
	boundingBox.y += _y;
}
int WorldItem::getLightID() {
	return	lightID;
}
void WorldItem::setLightOffset(float _x, float _y) {
	lightOffset.x = _x;
	lightOffset.y = _y;
}
glm::vec2 WorldItem::getLightOffset() {
	return lightOffset;
}
void WorldItem::run() {

}
GameEngine::Light WorldItem::getLight() {
	GameEngine::Light x;
	return x;
}
void WorldItem::runTimer() {
	if (despawns){
		deSpawnTimer--;
	}
}
int WorldItem::getTimer() {
	return deSpawnTimer;
}
void WorldItem::drawSpriteSheet() {
	spriteSheet.draw(boundingBox.x, boundingBox.y);
	spriteSheet.run();
}
void WorldItem::loadSpriteSheet() {

}
void WorldItem::draw() {

}#include "WorldItemCollection.h"
WorldItemCollection::WorldItemCollection(){}
WorldItemCollection::~WorldItemCollection(){}
void WorldItemCollection::init(LightCollection* _LC, GameEngine::SpriteBatch* _sb) {
	LC = _LC;
	sb = _sb;
}
void WorldItemCollection::addItem(WorldItemType _type, float _x, float _y, float _xv, float _yv) {
	int lightID = 0;
	GameEngine::Light tempLight;
	switch (_type)
	{
	case flare:
		worldItemVector.push_back(new Flare());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1, 700);
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->yv = _yv;
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->xv = _xv;
		worldItemVector[worldItemVector.size() - 1]->setType(flare);
		break;
	case flareParticle:
		worldItemVector.push_back(new FlareParticle());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 6, 18, 80);
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->yv = _yv;
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->xv = _xv;
		worldItemVector[worldItemVector.size() - 1]->setType(flareParticle);
		break;
	case fireParticle:
		worldItemVector.push_back(new FireParticle());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->linkSpriteBatch(sb);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1, 200);
		worldItemVector[worldItemVector.size() - 1]->setType(fireParticle);
		worldItemVector[worldItemVector.size() - 1]->hasSpriteSheet = true;
		worldItemVector[worldItemVector.size() - 1]->loadSpriteSheet();
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->yv = _yv;
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->xv = _xv;
		break;
	case explosionParticle:
		worldItemVector.push_back(new ExplosionParticle());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->linkSpriteBatch(sb);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1, 80);
		worldItemVector[worldItemVector.size() - 1]->setType(explosionParticle);
		worldItemVector[worldItemVector.size() - 1]->hasSpriteSheet = true;
		worldItemVector[worldItemVector.size() - 1]->loadSpriteSheet();
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->yv = _yv;
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->xv = _xv;
		break;
	case glowStick:
		worldItemVector.push_back(new GlowStick());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1);
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->yv = _yv;
		worldItemVector[worldItemVector.size() - 1]->getBoundingBox()->xv = _xv;
		worldItemVector[worldItemVector.size() - 1]->setType(glowStick);
		break;
	case default:

		break;
	}

	worldItemVector[worldItemVector.size() - 1]->setPosition(_x, _y);
	worldItemVector[worldItemVector.size() - 1]->setLightID(lightID);
}
void WorldItemCollection::addItem(WorldItemType _type, float _x, float _y) {
	int lightID = 0;
	GameEngine::Light tempLight;
	switch (_type)
	{ 
	case flare:
		worldItemVector.push_back(new Flare());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1, 700);
		worldItemVector[worldItemVector.size() - 1]->setType(flare);
		break;
	case explosion:
		worldItemVector.push_back(new Explosion());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->linkSpriteBatch(sb);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 60, 56, 28);
		worldItemVector[worldItemVector.size() - 1]->setType(explosion);
		worldItemVector[worldItemVector.size() - 1]->hasSpriteSheet = true;
		worldItemVector[worldItemVector.size() - 1]->loadSpriteSheet();
		break;
	case fireParticle:
		worldItemVector.push_back(new FireParticle());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->linkSpriteBatch(sb);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1, 200);
		worldItemVector[worldItemVector.size() - 1]->setType(fireParticle);
		worldItemVector[worldItemVector.size() - 1]->hasSpriteSheet = true;
		worldItemVector[worldItemVector.size() - 1]->loadSpriteSheet();
		break;
	case flareParticle:
		worldItemVector.push_back(new FlareParticle());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1, 80);
		worldItemVector[worldItemVector.size() - 1]->setType(flareParticle);
		break;
	case glowStick:
		worldItemVector.push_back(new GlowStick());
		tempLight = worldItemVector[worldItemVector.size() - 1]->getLight();
		lightID = LC->addLight(tempLight);
		worldItemVector[worldItemVector.size() - 1]->init(0, 0, 1, 1);
		worldItemVector[worldItemVector.size() - 1]->setType(glowStick);
		break;
	case default:
		
		break;
	}
	
	worldItemVector[worldItemVector.size() - 1]->setPosition(_x, _y);
	worldItemVector[worldItemVector.size() - 1]->setLightID(lightID);
}
void WorldItemCollection::runItems() {
	for (int i = 0; i < worldItemVector.size(); i++)
	{
		worldItemVector[i]->run();
		worldItemVector[i]->runTimer();
		if (worldItemVector[i]->getType() == flare && ((double)rand() / (RAND_MAX)) > 0.85) {
			addItem(flareParticle, worldItemVector[i]->getBoundingBox()->x, worldItemVector[i]->getBoundingBox()->y, ((double)rand() / (RAND_MAX)) * 6 - 3, ((double)rand() / (RAND_MAX)) * 16);
		}
		if (worldItemVector[i]->getType() == explosion) {
			if (((double)rand() / (RAND_MAX)) > 0.4 && worldItemVector[i]->getTimer() > 25) {
				//addItem(explosionParticle, worldItemVector[i]->getBoundingBox()->x + worldItemVector[i]->getBoundingBox()->w / 2, worldItemVector[i]->getBoundingBox()->y + worldItemVector[i]->getBoundingBox()->h / 2, ((double)rand() / (RAND_MAX)) * 6 - 3, ((double)rand() / (RAND_MAX)) * 14 - 4);

			}
			LC->addToRadius(worldItemVector[i]->getLightID(), -200/28 - 2);
		}
		if (worldItemVector[i]->getTimer() <= 0 && worldItemVector[i]->despawns)
		{
			remove(i);
		}
	}
}
void WorldItemCollection::drawItems() {
	for (int i = 0; i < worldItemVector.size(); i++)
	{
		if (worldItemVector[i]->hasSpriteSheet) {
			worldItemVector[i]->drawSpriteSheet();
		}
		
	}
}
void WorldItemCollection::linkToLights()
{
	for (int i = 0; i < worldItemVector.size(); i++)
	{
		if (worldItemVector[i]->getLightID() != -1) {
			glm::vec2 temppos = worldItemVector[i]->getLightOffset() + glm::vec2(worldItemVector[i]->getBoundingBox()->x, worldItemVector[i]->getBoundingBox()->y);
			LC->changePosition(worldItemVector[i]->getLightID(), temppos.x, temppos.y);
		}
	}
}
BoundingBox* WorldItemCollection::getBoundingBox(int _index) {
	return worldItemVector[_index]->getBoundingBox();
}
void WorldItemCollection::remove(int _index) {
	if (worldItemVector[_index]->getLightID() != -1) {
		LC->removeLight(worldItemVector[_index]->getLightID());
	}
	worldItemVector.erase(worldItemVector.begin() + _index);
}